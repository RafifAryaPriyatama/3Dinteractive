<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Particle Hand Control (Three.js + MediaPipe)</title>
  <style>
    :root{
      --bg:#070A10; --panel:rgba(255,255,255,.06); --stroke:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.9); --muted:rgba(255,255,255,.65);
      --accent:#7aa7ff;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 800px at 60% 30%, #0c1530 0%, var(--bg) 60%); overflow:hidden; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    #app{position:fixed; inset:0;}
    canvas{display:block;}
    .hud{
      position:fixed; left:16px; bottom:16px; padding:12px 14px;
      background:var(--panel); border:1px solid var(--stroke); border-radius:16px;
      backdrop-filter: blur(12px);
      color:var(--text); max-width:520px;
    }
    .hud h1{margin:0 0 6px 0; font-size:14px; letter-spacing:.2px;}
    .hud p{margin:0; color:var(--muted); font-size:12px; line-height:1.35;}
    .topbar{
      position:fixed; right:16px; top:16px; display:flex; gap:10px; align-items:center;
    }
    .btn{
      appearance:none; border:1px solid var(--stroke); background:var(--panel); color:var(--text);
      padding:10px 12px; border-radius:14px; cursor:pointer; font-size:12px;
      backdrop-filter: blur(12px);
      transition: transform .08s ease, border-color .15s ease;
    }
    .btn:hover{border-color:rgba(122,167,255,.55);}
    .btn:active{transform:scale(.98);}
    #status{
      padding:10px 12px; border-radius:14px; border:1px solid var(--stroke);
      background:var(--panel); color:var(--muted); font-size:12px;
      backdrop-filter: blur(12px);
      max-width:46ch;
    }
    /* video hidden */
    video{position:fixed; width:1px; height:1px; opacity:0; pointer-events:none;}
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="topbar">
    <div id="status">Memuat…</div>
    <button id="fs" class="btn">Fullscreen</button>
  </div>

  <div class="hud">
    <h1>3D Particle — Hand Control</h1>
    <p>
      Arahkan tangan ke kamera. Gerakan <b>buka-tutup (pinch)</b> mengontrol <b>kontraksi/ekspansi</b> dan <b>dispersi</b>.
      Gunakan panel (kanan) untuk ganti pola & warna.
    </p>
  </div>

  <video id="video" playsinline></video>

  <!-- Three.js -->
  <script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
  import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm";


    // --------- Basic Setup ----------
    const app = document.getElementById("app");
    const statusEl = document.getElementById("status");
    const fsBtn = document.getElementById("fs");

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x070a10, 0.045);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 0, 14);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.enablePan = false;

    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);

    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(6, 10, 8);
    scene.add(dir);

    // --------- Particles ----------
    const COUNT = 55000;

    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(COUNT * 3);
    const basePositions = new Float32Array(COUNT * 3);
    const velocities = new Float32Array(COUNT * 3);

    // A bit of randomness for motion
    for (let i=0;i<COUNT;i++){
      velocities[i*3+0] = (Math.random()*2-1) * 0.0012;
      velocities[i*3+1] = (Math.random()*2-1) * 0.0012;
      velocities[i*3+2] = (Math.random()*2-1) * 0.0012;
    }

    geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    const mat = new THREE.PointsMaterial({
      color: 0x7aa7ff,
      size: 0.045,
      transparent: true,
      opacity: 0.9,
      depthWrite: false
    });

    const points = new THREE.Points(geom, mat);
    scene.add(points);

    // --------- Pattern Generators ----------
    function setPattern(pattern){
      // Fill basePositions with chosen shape points
      const tmp = new THREE.Vector3();
      for (let i=0;i<COUNT;i++){
        let x=0,y=0,z=0;

        if (pattern === "Sphere"){
          // random points on/inside sphere
          const u = Math.random();
          const v = Math.random();
          const theta = 2*Math.PI*u;
          const phi = Math.acos(2*v-1);
          const r = Math.cbrt(Math.random()) * 4.2;
          x = r * Math.sin(phi) * Math.cos(theta);
          y = r * Math.sin(phi) * Math.sin(theta);
          z = r * Math.cos(phi);
        } else if (pattern === "Torus"){
          const R = 3.4, r = 1.2;
          const a = Math.random()*2*Math.PI;
          const b = Math.random()*2*Math.PI;
          x = (R + r*Math.cos(b)) * Math.cos(a);
          y = (R + r*Math.cos(b)) * Math.sin(a);
          z = r * Math.sin(b);
        } else if (pattern === "Helix"){
          const t = (i/COUNT) * 32*Math.PI;
          const rad = 2.4 + 0.6*Math.sin(t*0.25);
          x = rad * Math.cos(t);
          y = (i/COUNT - 0.5) * 9.0;
          z = rad * Math.sin(t);
          // small jitter
          x += (Math.random()*2-1)*0.08;
          y += (Math.random()*2-1)*0.08;
          z += (Math.random()*2-1)*0.08;
        } else if (pattern === "Grid"){
          // 3D lattice cloud
          const s = 9.0;
          x = (Math.random()-0.5)*s;
          y = (Math.random()-0.5)*s;
          z = (Math.random()-0.5)*s;
          const snap = 0.35;
          x = Math.round(x/snap)*snap;
          y = Math.round(y/snap)*snap;
          z = Math.round(z/snap)*snap;
        } else if (pattern === "Galaxy"){
          // spiral galaxy-ish
          const arms = 4;
          const r = Math.pow(Math.random(), 0.6) * 5.0;
          const arm = Math.floor(Math.random()*arms);
          const angle = (arm/arms)*2*Math.PI + r*0.75 + (Math.random()*2-1)*0.35;
          x = r*Math.cos(angle);
          z = r*Math.sin(angle);
          y = (Math.random()*2-1) * (0.25 + (1 - r/5.0)*0.9);
        }

        basePositions[i*3+0] = x;
        basePositions[i*3+1] = y;
        basePositions[i*3+2] = z;

        // initialize current pos to base pos
        positions[i*3+0] = x;
        positions[i*3+1] = y;
        positions[i*3+2] = z;
      }
      geom.attributes.position.needsUpdate = true;
    }

    // default
    setPattern("Sphere");

    // --------- UI (Minimal + Nice) ----------
    const settings = {
      Pattern: "Sphere",
      Color: "#7aa7ff",
      Size: 0.045,
      Smoothness: 0.12,
      Orbit: true,
      DisperseStrength: 1.15,
      ScaleRange: 2.8,
      ShowHelp: true
    };

    const gui = new GUI({ title: "Particle Controls" });
    gui.domElement.style.borderRadius = "16px";
    gui.domElement.style.backdropFilter = "blur(12px)";
    gui.domElement.style.background = "rgba(255,255,255,.06)";
    gui.domElement.style.border = "1px solid rgba(255,255,255,.12)";

    gui.add(settings, "Pattern", ["Sphere","Torus","Helix","Grid","Galaxy"])
      .onChange(v => setPattern(v));
    gui.addColor(settings, "Color").onChange(v => mat.color.set(v));
    gui.add(settings, "Size", 0.01, 0.12, 0.001).onChange(v => mat.size = v);
    gui.add(settings, "Smoothness", 0.04, 0.25, 0.005);
    gui.add(settings, "DisperseStrength", 0.2, 3.0, 0.05);
    gui.add(settings, "ScaleRange", 1.0, 6.0, 0.1);
    gui.add(settings, "Orbit").onChange(v => controls.enabled = v);

    // --------- Fullscreen ----------
    fsBtn.addEventListener("click", async () => {
      if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    });

    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // --------- Hand Tracking (MediaPipe Hands) ----------
    // Using UMD scripts (loaded below) but controlled here.
    const video = document.getElementById("video");

    let pinch01 = 0;          // smoothed pinch amount [0..1]
    let targetPinch01 = 0;    // raw target
    let handOk = false;

    function lerp(a,b,t){ return a + (b-a)*t; }
    function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    // Maps pinch distance to control:
    // pinch closed => small distance => targetPinch01 ~ 1
    // hand open => big distance => targetPinch01 ~ 0
    function computePinch01(landmarks){
      // thumb tip = 4, index tip = 8 (MediaPipe)
      const t = landmarks[4];
      const i = landmarks[8];
      const dx = t.x - i.x;
      const dy = t.y - i.y;
      const dz = (t.z || 0) - (i.z || 0);
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz); // normalized-ish
      // empirical mapping
      const openDist = 0.22;  // more open
      const closeDist = 0.05; // pinched
      const v = 1 - (dist - closeDist) / (openDist - closeDist);
      return clamp(v, 0, 1);
    }

    function setStatus(text, ok=false){
      statusEl.textContent = text;
      statusEl.style.color = ok ? "rgba(255,255,255,.9)" : "rgba(255,255,255,.65)";
    }

    async function initCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode:"user", width: 640, height: 480 },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        return true;
      } catch(err){
        console.error(err);
        setStatus("Kamera tidak bisa diakses. Jalankan via https atau localhost.", false);
        return false;
      }
    }

    // --------- Animation / Particle Response ----------
    let t0 = performance.now();

    function animate(){
      requestAnimationFrame(animate);
      const t = performance.now();
      const dt = Math.min((t - t0) / 16.67, 2.0);
      t0 = t;

      controls.update();

      // Smooth pinch signal
      pinch01 = lerp(pinch01, targetPinch01, settings.Smoothness);
      // Map pinch to scale + disperse:
      // pinch01=1 (closed) => contract (smaller scale), less disperse
      // pinch01=0 (open)   => expand (bigger scale), more disperse
      const scale = 1 + (1 - pinch01) * settings.ScaleRange;       // open => bigger
      const contract = 0.55 + pinch01 * 0.75;                      // closed => more compact
      const disperse = (1 - pinch01) * settings.DisperseStrength;  // open => more disperse

      // subtle scene rotation when not orbiting
      if (!controls.enabled){
        points.rotation.y += 0.0025 * dt;
        points.rotation.x += 0.0010 * dt;
      }

      // Update positions towards target with little flow noise
      const p = geom.attributes.position.array;
      for (let i=0;i<COUNT;i++){
        const idx = i*3;

        // base point
        let bx = basePositions[idx+0] * contract;
        let by = basePositions[idx+1] * contract;
        let bz = basePositions[idx+2] * contract;

        // disperse along radial direction
        const len = Math.sqrt(bx*bx + by*by + bz*bz) + 1e-6;
        const rx = bx/len, ry = by/len, rz = bz/len;
        bx += rx * disperse * 2.4;
        by += ry * disperse * 2.4;
        bz += rz * disperse * 2.4;

        // final scaled target
        const tx = bx * (scale * 0.65);
        const ty = by * (scale * 0.65);
        const tz = bz * (scale * 0.65);

        // current
        let cx = p[idx+0], cy = p[idx+1], cz = p[idx+2];

        // gentle drift / fluid feel
        cx += velocities[idx+0] * dt;
        cy += velocities[idx+1] * dt;
        cz += velocities[idx+2] * dt;

        // pull towards target (spring)
        const pull = 0.05 * dt;
        cx = lerp(cx, tx, pull);
        cy = lerp(cy, ty, pull);
        cz = lerp(cz, tz, pull);

        p[idx+0] = cx;
        p[idx+1] = cy;
        p[idx+2] = cz;
      }
      geom.attributes.position.needsUpdate = true;

      // status
      if (handOk) setStatus(`Tangan terdeteksi • Pinch ${(pinch01*100).toFixed(0)}%`, true);
      else setStatus("Cari tangan di kamera… (pastikan pencahayaan cukup)", false);

      renderer.render(scene, camera);
    }

    // --------- Start everything ----------
    (async () => {
      setStatus("Minta izin kamera…");
      const camOk = await initCamera();
      if (!camOk) return;

      setStatus("Memuat model hand tracking…");

      // Wait until MediaPipe scripts are loaded (defined globally)
      await new Promise((resolve) => {
        const check = () => (window.Hands && window.Camera) ? resolve() : setTimeout(check, 50);
        check();
      });

      const hands = new window.Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length){
          handOk = true;
          const lm = results.multiHandLandmarks[0];
          targetPinch01 = computePinch01(lm);
        } else {
          handOk = false;
          targetPinch01 = 0; // default open-ish
        }
      });

      // MediaPipe Camera helper
      const mpCam = new window.Camera(video, {
        onFrame: async () => { await hands.send({ image: video }); },
        width: 640,
        height: 480
      });
      mpCam.start();

      setStatus("Jalan. Arahkan tangan ke kamera.", true);
      animate();
    })();
  </script>

  <!-- MediaPipe Hands + camera utils (UMD global) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</body>
</html>
